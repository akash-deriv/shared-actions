name: DocSync AI - Update from Comment
description: Update documentation in existing DocSync PR based on user comment suggestions

inputs:
  github_token:
    description: "GitHub token for repository operations and PR creation"
    required: true
  anthropic_api_key:
    description: "Anthropic API key for Claude AI"
    required: true
  repository:
    description: "Repository name (owner/repo)"
    required: true
  pr_number:
    description: "PR number where comment was made"
    required: true
  comment_body:
    description: "Comment body with user suggestion (must start with '@docbot' or 'docsync:')"
    required: true
  base_branch:
    description: "Base branch for documentation PR (e.g., master or main)"
    required: false
    default: "master"

outputs:
  updated:
    description: "Whether documentation was updated"
    value: ${{ steps.commit-changes.outputs.updated }}
  suggestion_valid:
    description: "Whether the comment had valid docsync prefix"
    value: ${{ steps.validate.outputs.valid }}
  is_docsync_pr:
    description: "Whether the PR is a DocSync PR"
    value: ${{ steps.verify-pr.outputs.is_docsync_pr }}

runs:
  using: composite
  steps:
    - name: ‚úÖ Validate and Parse Comment
      id: validate
      shell: bash
      env:
        COMMENT_BODY: ${{ inputs.comment_body }}
      run: |
        set -e

        echo "## ‚úÖ Validating Comment" >> $GITHUB_STEP_SUMMARY

        # Sanitize comment body (remove null bytes, limit size)
        COMMENT_BODY_CLEAN=$(echo "$COMMENT_BODY" | tr -d '\000' | iconv -c -t UTF-8//IGNORE | head -c 10000)

        # Validate for suspicious patterns
        if echo "$COMMENT_BODY_CLEAN" | grep -qE '\$\(|\`|;[[:space:]]*curl|;[[:space:]]*wget|eval|exec'; then
          echo "‚ö†Ô∏è Warning: Suspicious pattern detected in comment" >> $GITHUB_STEP_SUMMARY
          # Continue but log warning
        fi

        COMMAND_TYPE=""
        COMMAND_ACTION=""
        COMMAND_TARGET=""
        SUGGESTION=""

        # Check if comment starts with "@docbot" (case-insensitive)
        if echo "$COMMENT_BODY_CLEAN" | grep -qiE "^@docbot[[:space:]]"; then
          COMMAND_TYPE="docbot"
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Valid @docbot command detected" >> $GITHUB_STEP_SUMMARY

          # Extract command (everything after "@docbot ")
          COMMAND_TEXT=$(echo "$COMMENT_BODY_CLEAN" | sed -E 's/^@[Dd][Oo][Cc][Bb][Oo][Tt][[:space:]]+//')

          # Parse command action (first word)
          COMMAND_ACTION=$(echo "$COMMAND_TEXT" | awk '{print tolower($1)}')

          # Parse command target (rest of the command)
          COMMAND_TARGET=$(echo "$COMMAND_TEXT" | sed -E 's/^[^[:space:]]+[[:space:]]*//')

          # Validate command is not empty
          if [ -z "$COMMAND_ACTION" ]; then
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå @docbot command is empty" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Set outputs
          echo "command_type=$COMMAND_TYPE" >> $GITHUB_OUTPUT
          echo "command_action=$COMMAND_ACTION" >> $GITHUB_OUTPUT
          echo "command_target<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMAND_TARGET" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Create formatted suggestion for Claude based on command
          case "$COMMAND_ACTION" in
            update)
              SUGGESTION="Update the $COMMAND_TARGET with improvements and refinements"
              ;;
            clarify)
              SUGGESTION="Clarify and make the following section more detailed: $COMMAND_TARGET"
              ;;
            add)
              SUGGESTION="Add $COMMAND_TARGET to the documentation"
              ;;
            expand)
              SUGGESTION="Expand the documentation on: $COMMAND_TARGET"
              ;;
            fix)
              SUGGESTION="Fix the following issue in the documentation: $COMMAND_TARGET"
              ;;
            revert)
              echo "command_is_revert=true" >> $GITHUB_OUTPUT
              SUGGESTION="REVERT: $COMMAND_TARGET"
              ;;
            approve)
              echo "command_is_approve=true" >> $GITHUB_OUTPUT
              SUGGESTION="APPROVE"
              ;;
            reject)
              echo "command_is_reject=true" >> $GITHUB_OUTPUT
              SUGGESTION="REJECT"
              ;;
            *)
              SUGGESTION="$COMMAND_TEXT"
              ;;
          esac

          echo "suggestion<<EOF" >> $GITHUB_OUTPUT
          echo "$SUGGESTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "### @docbot Command:" >> $GITHUB_STEP_SUMMARY
          echo "- **Action**: $COMMAND_ACTION" >> $GITHUB_STEP_SUMMARY
          echo "- **Target**: ${COMMAND_TARGET:-(none)}" >> $GITHUB_STEP_SUMMARY

        # Check if comment starts with "docsync:" (case-insensitive) - legacy format
        elif echo "$COMMENT_BODY_CLEAN" | grep -qiE "^docsync:[[:space:]]"; then
          COMMAND_TYPE="legacy"
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Valid docsync comment detected (legacy format)" >> $GITHUB_STEP_SUMMARY

          # Extract suggestion safely (everything after "docsync:")
          SUGGESTION=$(echo "$COMMENT_BODY_CLEAN" | sed -E 's/^[Dd][Oo][Cc][Ss][Yy][Nn][Cc]:[[:space:]]*//')

          # Validate suggestion is not empty
          if [ -z "$SUGGESTION" ]; then
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå Comment suggestion is empty" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          echo "command_type=$COMMAND_TYPE" >> $GITHUB_OUTPUT
          echo "suggestion<<EOF" >> $GITHUB_OUTPUT
          echo "$SUGGESTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "### User Suggestion (Legacy):" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "${SUGGESTION:0:500}" >> $GITHUB_STEP_SUMMARY
          if [ ${#SUGGESTION} -gt 500 ]; then
            echo "... (truncated for display)" >> $GITHUB_STEP_SUMMARY
          fi
          echo '```' >> $GITHUB_STEP_SUMMARY

        else
          echo "valid=false" >> $GITHUB_OUTPUT
          echo "‚ùå Comment does not start with '@docbot' or 'docsync:' - skipping" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

    - name: üîç Verify DocSync PR
      id: verify-pr
      if: steps.validate.outputs.valid == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        REPO_NAME: ${{ inputs.repository }}
      run: |
        set -e

        echo "## üîç Verifying DocSync PR" >> $GITHUB_STEP_SUMMARY

        # Validate PR number
        if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
          echo "‚ùå Invalid PR number: $PR_NUMBER" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        if [ "$PR_NUMBER" -lt 1 ] || [ "$PR_NUMBER" -gt 999999 ]; then
          echo "‚ùå PR number out of valid range: $PR_NUMBER" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Validate repository format
        if ! [[ "$REPO_NAME" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
          echo "‚ùå Invalid repository format: $REPO_NAME" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Get PR details including labels and title
        PR_DATA=$(gh api \
          -H "Accept: application/vnd.github+json" \
          "/repos/$REPO_NAME/pulls/$PR_NUMBER")

        # Validate response is valid JSON
        if ! echo "$PR_DATA" | jq empty 2>/dev/null; then
          echo "‚ùå Invalid response from GitHub API" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Extract labels
        PR_LABELS=$(echo "$PR_DATA" | jq -r '.labels[].name' 2>&1 || echo "")

        # Extract PR title and sanitize
        PR_TITLE=$(echo "$PR_DATA" | jq -r '.title' 2>&1 || echo "")
        PR_TITLE=$(echo "$PR_TITLE" | tr -d '\000-\037' | head -c 200)

        # Extract PR branch and validate
        PR_BRANCH=$(echo "$PR_DATA" | jq -r '.head.ref' 2>&1 || echo "")

        # Validate branch name format
        if ! [[ "$PR_BRANCH" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
          echo "‚ùå Invalid branch name format" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Sanitize labels for display
        PR_LABELS_DISPLAY=$(echo "$PR_LABELS" | head -n 10)

        echo "### PR Information:" >> $GITHUB_STEP_SUMMARY
        echo "- **Title**: ${PR_TITLE:0:100}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: $PR_BRANCH" >> $GITHUB_STEP_SUMMARY
        echo "- **Labels**: ${PR_LABELS_DISPLAY:-'(none)'}" >> $GITHUB_STEP_SUMMARY

        # Check if PR has docsync-ai or automated label, OR if title contains "DocSync"
        IS_DOCSYNC_PR=false

        if echo "$PR_LABELS" | grep -qE "(docsync-ai|automated)"; then
          IS_DOCSYNC_PR=true
          echo "‚úÖ PR has DocSync label" >> $GITHUB_STEP_SUMMARY
        elif echo "$PR_TITLE" | grep -qi "docsync"; then
          IS_DOCSYNC_PR=true
          echo "‚úÖ PR title contains 'DocSync'" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$IS_DOCSYNC_PR" = true ]; then
          echo "is_docsync_pr=true" >> $GITHUB_OUTPUT
          echo "pr_branch=$PR_BRANCH" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Verified as DocSync PR**" >> $GITHUB_STEP_SUMMARY
        else
          echo "is_docsync_pr=false" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ùå **Not a DocSync PR**" >> $GITHUB_STEP_SUMMARY
          echo "This feature only works on DocSync PRs (with 'docsync-ai'/'automated' labels or 'DocSync' in title)" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

    - name: üì• Checkout PR Branch
      if: steps.verify-pr.outputs.is_docsync_pr == 'true'
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.github_token }}
        ref: ${{ steps.verify-pr.outputs.pr_branch }}
        fetch-depth: 0

    - name: üîÑ Handle Revert Command
      id: handle-revert
      if: steps.verify-pr.outputs.is_docsync_pr == 'true' && steps.validate.outputs.command_is_revert == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
        COMMAND_TARGET: ${{ steps.validate.outputs.command_target }}
      run: |
        set -e

        echo "## üîÑ Processing Revert Command" >> $GITHUB_STEP_SUMMARY

        # Configure git
        git config --local user.name "github-actions[bot]"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"

        # Parse revert target
        REVERT_TARGET=$(echo "$COMMAND_TARGET" | xargs)

        if echo "$REVERT_TARGET" | grep -qiE "^last[[:space:]]+change"; then
          # Revert to previous commit
          echo "Reverting to previous commit..." >> $GITHUB_STEP_SUMMARY

          # Check if there's more than one commit
          COMMIT_COUNT=$(git rev-list --count HEAD)
          if [ "$COMMIT_COUNT" -le 1 ]; then
            echo "‚ùå Cannot revert: only one commit in branch" >> $GITHUB_STEP_SUMMARY
            echo "reverted=false" >> $GITHUB_OUTPUT

            COMMENT_BODY=$(jq -n '"‚ùå **Cannot Revert**

            There is only one commit in this branch, so there is nothing to revert to.

            ---
            ü§ñ *Automated by DocSync AI*"
            ' -r)

            gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
            exit 0
          fi

          # Revert last commit
          git reset --hard HEAD~1
          git push --force origin HEAD

          COMMENT_BODY=$(jq -n '"üîÑ **Reverted Last Change**

          The most recent documentation change has been reverted.

          ---
          ü§ñ *Automated by DocSync AI*"
          ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "reverted=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Successfully reverted last change" >> $GITHUB_STEP_SUMMARY

        elif echo "$REVERT_TARGET" | grep -qiE "^to[[:space:]]+[a-f0-9]+"; then
          # Revert to specific commit
          COMMIT_HASH=$(echo "$REVERT_TARGET" | sed -E 's/^to[[:space:]]+([a-f0-9]+).*/\1/')

          # Validate commit hash format
          if ! [[ "$COMMIT_HASH" =~ ^[a-f0-9]{6,40}$ ]]; then
            echo "‚ùå Invalid commit hash format" >> $GITHUB_STEP_SUMMARY
            echo "reverted=false" >> $GITHUB_OUTPUT

            COMMENT_BODY=$(jq -n \
              --arg hash "$COMMIT_HASH" \
              '"‚ùå **Invalid Commit Hash**

              The commit hash `\($hash)` is not valid.

              Commit hashes should be 6-40 hexadecimal characters (0-9, a-f).

              **Example:** `@docbot revert to abc1234`

              ---
              ü§ñ *Automated by DocSync AI*"
              ' -r)

            gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
            exit 0
          fi

          echo "Reverting to commit $COMMIT_HASH..." >> $GITHUB_STEP_SUMMARY

          # Check if commit exists
          if ! git cat-file -e "$COMMIT_HASH" 2>/dev/null; then
            echo "‚ùå Commit $COMMIT_HASH not found" >> $GITHUB_STEP_SUMMARY
            echo "reverted=false" >> $GITHUB_OUTPUT

            COMMENT_BODY=$(jq -n \
              --arg hash "$COMMIT_HASH" \
              '"‚ùå **Commit Not Found**

              The commit `\($hash)` does not exist in this branch.

              You can find valid commit hashes by viewing the commit history of this PR.

              ---
              ü§ñ *Automated by DocSync AI*"
              ' -r)

            gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
            exit 0
          fi

          # Reset to specified commit
          git reset --hard "$COMMIT_HASH"
          git push --force origin HEAD

          COMMENT_BODY=$(jq -n \
            --arg hash "$COMMIT_HASH" \
            '"üîÑ **Reverted to Commit**

            Reverted to commit: `\($hash)`

            ---
            ü§ñ *Automated by DocSync AI*"
            ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "reverted=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Successfully reverted to commit $COMMIT_HASH" >> $GITHUB_STEP_SUMMARY

        else
          echo "‚ùå Invalid revert command format" >> $GITHUB_STEP_SUMMARY
          echo "reverted=false" >> $GITHUB_OUTPUT

          # Post helpful error message
          COMMENT_BODY=$(jq -n '"‚ùå **Invalid Revert Command**

          The revert command format was not recognized.

          **Valid formats:**
          - `@docbot revert last change` - Reverts the most recent commit
          - `@docbot revert to <commit-hash>` - Reverts to a specific commit (e.g., `@docbot revert to abc1234`)

          Please use one of these formats and try again.

          ---
          ü§ñ *Automated by DocSync AI*"
          ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
        fi

    - name: ‚úÖ Handle Approve Command
      id: handle-approve
      if: steps.verify-pr.outputs.is_docsync_pr == 'true' && steps.validate.outputs.command_is_approve == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
      run: |
        set -e

        echo "## ‚úÖ Processing Approve Command" >> $GITHUB_STEP_SUMMARY

        # Check if there's a pending review branch
        REVIEW_BRANCH="docsync-review-$PR_NUMBER"

        if git ls-remote --heads origin "$REVIEW_BRANCH" | grep -q "$REVIEW_BRANCH"; then
          echo "Found pending review branch: $REVIEW_BRANCH" >> $GITHUB_STEP_SUMMARY

          # Fetch and merge the review branch
          git fetch origin "$REVIEW_BRANCH"
          git merge "origin/$REVIEW_BRANCH" -m "üìö DocSync AI: Apply approved changes"
          git push origin HEAD

          # Delete the review branch
          git push origin --delete "$REVIEW_BRANCH"

          COMMENT_BODY=$(jq -n '"‚úÖ **Changes Approved and Applied**

          The proposed documentation changes have been approved and committed to this PR.

          ---
          ü§ñ *Automated by DocSync AI*"
          ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "approved=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Successfully applied approved changes" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ùå No pending changes to approve" >> $GITHUB_STEP_SUMMARY
          echo "approved=false" >> $GITHUB_OUTPUT

          COMMENT_BODY=$(jq -n '"‚ùå **No Pending Changes**

          There are no pending changes to approve.

          Documentation changes are shown for review before being applied. Please wait for a documentation update to be generated first.

          ---
          ü§ñ *Automated by DocSync AI*"
          ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
        fi

    - name: ‚ùå Handle Reject Command
      id: handle-reject
      if: steps.verify-pr.outputs.is_docsync_pr == 'true' && steps.validate.outputs.command_is_reject == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
      run: |
        set -e

        echo "## ‚ùå Processing Reject Command" >> $GITHUB_STEP_SUMMARY

        # Check if there's a pending review branch
        REVIEW_BRANCH="docsync-review-$PR_NUMBER"

        if git ls-remote --heads origin "$REVIEW_BRANCH" | grep -q "$REVIEW_BRANCH"; then
          echo "Found pending review branch: $REVIEW_BRANCH" >> $GITHUB_STEP_SUMMARY

          # Delete the review branch without merging
          git push origin --delete "$REVIEW_BRANCH"

          COMMENT_BODY=$(jq -n '"‚ùå **Changes Rejected**

          The proposed documentation changes have been rejected and discarded.

          ---
          ü§ñ *Automated by DocSync AI*"
          ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "rejected=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Successfully rejected proposed changes" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ùå No pending changes to reject" >> $GITHUB_STEP_SUMMARY
          echo "rejected=false" >> $GITHUB_OUTPUT

          COMMENT_BODY=$(jq -n '"‚ùå **No Pending Changes**

          There are no pending changes to reject.

          ---
          ü§ñ *Automated by DocSync AI*"
          ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
        fi

    - name: ü§ñ Run Claude 3.7 Sonnet Documentation Analysis
      id: claude-analysis
      if: steps.verify-pr.outputs.is_docsync_pr == 'true' && steps.handle-revert.outputs.reverted != 'true' && steps.handle-approve.outputs.approved != 'true' && steps.handle-reject.outputs.rejected != 'true'
      shell: bash
      env:
        ANTHROPIC_API_KEY: ${{ inputs.anthropic_api_key }}
        REPO_NAME: ${{ inputs.repository }}
        PR_NUMBER: ${{ inputs.pr_number }}
        USER_SUGGESTION: ${{ steps.validate.outputs.suggestion }}
      run: |
        set -e

        echo "## ü§ñ Claude 3.7 Sonnet Analysis" >> $GITHUB_STEP_SUMMARY
        echo "Model: claude-3-7-sonnet-latest" >> $GITHUB_STEP_SUMMARY

        # Create secure temporary directory
        TEMP_DIR=$(mktemp -d -t docsync-comment-XXXXXXXXXX)
        trap "rm -rf '$TEMP_DIR'" EXIT

        # Sanitize user suggestion
        USER_SUGGESTION_CLEAN=$(echo "$USER_SUGGESTION" | tr -d '\000' | iconv -c -t UTF-8//IGNORE | head -c 10000)

        # Validate file paths helper function
        validate_doc_file() {
          local file=$1
          # Must be in current directory, not a symlink, and match expected names
          if [[ ! -f "$file" ]] || [[ -L "$file" ]]; then
            return 1
          fi
          local basename=$(basename "$file")
          local basename_lower=$(echo "$basename" | tr '[:upper:]' '[:lower:]')
          if [[ "$basename_lower" != "readme.md" ]] && [[ "$basename_lower" != "claude.md" ]]; then
            return 1
          fi
          # Ensure file is in repo root (no directory traversal)
          local realpath=$(realpath "$file" 2>/dev/null || echo "")
          local workdir=$(realpath . 2>/dev/null || echo "")
          if [[ ! "$realpath" == "$workdir"/* ]]; then
            return 1
          fi
          return 0
        }

        # === PHASE 1: DETECT ALL DOCUMENTATION FILES ===
        # Check for BOTH files before updating anything
        HAS_README=false
        HAS_CLAUDE=false

        # Case-insensitive check for README.md
        README_FILE=$(find . -maxdepth 1 -type f -iname "readme.md" -print -quit 2>/dev/null)
        if [ -n "$README_FILE" ]; then
          README_FILE="${README_FILE#./}"
          if validate_doc_file "$README_FILE"; then
            HAS_README=true
          else
            echo "‚ö†Ô∏è Invalid README file detected, skipping" >> $GITHUB_STEP_SUMMARY
            README_FILE=""
          fi
        fi

        # Case-insensitive check for CLAUDE.md
        CLAUDE_FILE=$(find . -maxdepth 1 -type f -iname "claude.md" -print -quit 2>/dev/null)
        if [ -n "$CLAUDE_FILE" ]; then
          CLAUDE_FILE="${CLAUDE_FILE#./}"
          if validate_doc_file "$CLAUDE_FILE"; then
            HAS_CLAUDE=true
          else
            echo "‚ö†Ô∏è Invalid CLAUDE file detected, skipping" >> $GITHUB_STEP_SUMMARY
            CLAUDE_FILE=""
          fi
        fi

        # Log detection results for both files
        echo "### üìÑ Documentation File Detection:" >> $GITHUB_STEP_SUMMARY
        echo "- README.md: $([ "$HAS_README" = true ] && echo "‚úÖ Found ($README_FILE)" || echo '‚ùå Not found')" >> $GITHUB_STEP_SUMMARY
        echo "- CLAUDE.md: $([ "$HAS_CLAUDE" = true ] && echo "‚úÖ Found ($CLAUDE_FILE)" || echo '‚ùå Not found')" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = false ] && [ "$HAS_CLAUDE" = false ]; then
          echo "‚ùå No documentation file found (README.md or CLAUDE.md)" >> $GITHUB_STEP_SUMMARY
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        ANY_UPDATES=false

        # Function to call Claude API for documentation update
        update_doc_file() {
          local DOC_FILE=$1
          local DOC_FORMAT=$2
          local OTHER_FILES_NOTE=$3

          echo "Processing $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          # Validate doc file path
          if ! validate_doc_file "$DOC_FILE"; then
            echo "  ‚ùå Invalid doc file: $DOC_FILE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Read current documentation
          DOC_CONTENT=$(cat "$DOC_FILE")

          # Validate content size
          CONTENT_SIZE=${#DOC_CONTENT}
          MAX_CONTENT_SIZE=524288  # 512KB
          if [ $CONTENT_SIZE -gt $MAX_CONTENT_SIZE ]; then
            echo "  ‚ö†Ô∏è Doc file too large: $CONTENT_SIZE bytes" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Prepare the prompt based on file type
          if [ "$DOC_FORMAT" = "README" ]; then
            FORMAT_INSTRUCTION="This is a README.md file. Maintain standard README format with clear sections, proper markdown formatting, badges, installation instructions, usage examples, and project overview. Keep the professional, user-facing documentation style."
          else
            FORMAT_INSTRUCTION="This is a CLAUDE.md file for AI assistance. Maintain the technical, detailed format suitable for AI context with implementation details, architecture notes, and development guidelines. Keep the detailed, technical documentation style."
          fi

          # Create secure prompt file
          PROMPT_FILE="$TEMP_DIR/claude_prompt_$(openssl rand -hex 8).txt"

          # Build prompt with safe variable substitution using jq
          jq -n \
            --arg repo_name "$REPO_NAME" \
            --arg pr_number "$PR_NUMBER" \
            --arg doc_file "$DOC_FILE" \
            --arg doc_content "$DOC_CONTENT" \
            --arg user_suggestion "$USER_SUGGESTION_CLEAN" \
            --arg format_instruction "$FORMAT_INSTRUCTION" \
            --arg other_files_note "$OTHER_FILES_NOTE" \
            '"You are a technical documentation expert. A user has provided a suggestion for improving the documentation in a DocSync PR.

            # Context
            Repository: \($repo_name)
            PR #\($pr_number) (DocSync Documentation PR)

            # Current \($doc_file):
            \($doc_content)

            # User Suggestion:
            \($user_suggestion)

            # Format Requirements:
            \($format_instruction)

            # Documentation Context:
            \($other_files_note)

            # Your Task
            Apply the user''s suggestion to update the \($doc_file).

            ## CRITICAL RULES - MUST FOLLOW:
            1. **Direct output only**: Output ONLY the updated documentation content. NO acknowledgments like \"I will apply\", \"I understand\", \"Here''s the updated\", or any explanatory text.
            2. **Maintain format**: Keep the exact same documentation style and structure as the current file.
            3. **Follow user intent**: Carefully interpret and apply the user''s suggestion. If the suggestion is vague, make reasonable improvements.
            4. **Update relevant sections**: Only modify sections relevant to the suggestion. Keep everything else exactly as is.
            5. **Complete file output**: Provide the COMPLETE updated file content, not just the changed sections.
            6. **No meta-commentary**: No phrases like \"I''ve updated\", \"Changes made\", or section summaries.
            7. **Quality standards**: Ensure updates are accurate, clear, and improve documentation quality.

            Start your response immediately with the complete updated \($doc_file) content. Nothing else."
            ' -r > "$PROMPT_FILE"

          chmod 600 "$PROMPT_FILE"
          FULL_PROMPT=$(cat "$PROMPT_FILE")

          # Call Claude API with secure header handling
          echo "  Calling Claude API for $DOC_FILE..." >> $GITHUB_STEP_SUMMARY

          # Create secure request body file
          REQUEST_FILE="$TEMP_DIR/request_$(openssl rand -hex 8).json"
          jq -n \
            --arg model "claude-3-7-sonnet-latest" \
            --argjson max_tokens 8192 \
            --arg content "$FULL_PROMPT" \
            '{
              model: $model,
              max_tokens: $max_tokens,
              messages: [{
                role: "user",
                content: $content
              }]
            }' > "$REQUEST_FILE"

          chmod 600 "$REQUEST_FILE"

          # Call API
          RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d @"$REQUEST_FILE")

          # Clean up request file
          rm -f "$REQUEST_FILE"

          # Validate response is valid JSON
          if ! echo "$RESPONSE" | jq empty 2>/dev/null; then
            echo "  ‚ùå Invalid JSON response from API" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Check for API errors
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_TYPE=$(echo "$RESPONSE" | jq -r '.error.type // "unknown"')
            ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error.code // "unknown"')
            echo "  ‚ùå Claude API Error for $DOC_FILE: type=$ERROR_TYPE, code=$ERROR_CODE" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Validate response structure
          if ! echo "$RESPONSE" | jq -e '.content[0].text' > /dev/null 2>&1; then
            echo "  ‚ùå API response missing expected content field" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Extract the response content
          CLAUDE_OUTPUT=$(echo "$RESPONSE" | jq -r '.content[0].text')

          # Validate output size
          OUTPUT_SIZE=${#CLAUDE_OUTPUT}
          MAX_OUTPUT_SIZE=524288  # 512KB
          if [ $OUTPUT_SIZE -gt $MAX_OUTPUT_SIZE ]; then
            echo "  ‚ùå Claude output too large: $OUTPUT_SIZE bytes" >> $GITHUB_STEP_SUMMARY
            return 1
          fi

          # Sanitize output (remove null bytes, validate UTF-8)
          CLAUDE_OUTPUT=$(echo "$CLAUDE_OUTPUT" | tr -d '\000' | iconv -c -t UTF-8//IGNORE)

          echo "  ‚úÖ Updating $DOC_FILE" >> $GITHUB_STEP_SUMMARY
          # Write the updated documentation
          echo "$CLAUDE_OUTPUT" > "$DOC_FILE"
          ANY_UPDATES=true
          return 0
        }

        # === PHASE 2: UPDATE ALL DETECTED DOCUMENTATION FILES ===
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìù Updating Documentation Files:" >> $GITHUB_STEP_SUMMARY

        if [ "$HAS_README" = true ] && [ "$HAS_CLAUDE" = true ]; then
          echo "Both $README_FILE and $CLAUDE_FILE detected ‚Äî updating both" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "$CLAUDE_FILE also exists in this repository and is being updated separately for AI/Claude Code context. Focus this $README_FILE update on user-facing documentation only." || echo "  ‚ö†Ô∏è Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "$README_FILE also exists in this repository and is being updated separately for user-facing documentation. Focus this $CLAUDE_FILE update on AI/Claude Code technical context only." || echo "  ‚ö†Ô∏è Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_README" = true ]; then
          echo "Only $README_FILE detected ‚Äî updating $README_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$README_FILE" "README" "This is the only documentation file in the repository." || echo "  ‚ö†Ô∏è Failed to update $README_FILE" >> $GITHUB_STEP_SUMMARY
        elif [ "$HAS_CLAUDE" = true ]; then
          echo "Only $CLAUDE_FILE detected ‚Äî updating $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
          update_doc_file "$CLAUDE_FILE" "CLAUDE" "This is the only documentation file in the repository." || echo "  ‚ö†Ô∏è Failed to update $CLAUDE_FILE" >> $GITHUB_STEP_SUMMARY
        fi

        # Set final output
        if [ "$ANY_UPDATES" = true ]; then
          echo "skip_analysis=false" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìù Documentation files have been updated" >> $GITHUB_STEP_SUMMARY
        else
          echo "skip_analysis=true" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è No documentation updates were applied" >> $GITHUB_STEP_SUMMARY
        fi

    - name: üìã Show Changes for Approval
      id: show-changes
      if: steps.claude-analysis.outputs.skip_analysis != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
      run: |
        set -e

        # Check if documentation files were modified
        git add -A

        if git diff --cached --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "‚úÖ No documentation updates needed" >> $GITHUB_STEP_SUMMARY
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "üìù Documentation updates detected" >> $GITHUB_STEP_SUMMARY

          # Show what changed
          echo "### Changed Files:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          git diff --cached --name-only >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          # Verify only documentation files changed
          CHANGED=$(git diff --cached --name-only)
          INVALID_FILES=""

          for file in $CHANGED; do
            FILE_LOWER=$(echo "$file" | tr '[:upper:]' '[:lower:]')
            if [[ "$FILE_LOWER" != "readme.md" ]] && [[ "$FILE_LOWER" != "claude.md" ]]; then
              INVALID_FILES="$INVALID_FILES $file"
            fi
          done

          if [ -n "$INVALID_FILES" ]; then
            echo "‚ùå ERROR: Non-documentation files were modified:$INVALID_FILES" >> $GITHUB_STEP_SUMMARY
            echo "Only README.md and CLAUDE.md (any casing) should be updated." >> $GITHUB_STEP_SUMMARY
            git reset --hard
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Configure git
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"

          # Create review branch
          REVIEW_BRANCH="docsync-review-$PR_NUMBER"

          # Delete old review branch if it exists
          git push origin --delete "$REVIEW_BRANCH" 2>/dev/null || true

          # Create and push to review branch
          git checkout -b "$REVIEW_BRANCH"
          git commit -m "üìö DocSync AI: Proposed documentation changes (pending approval)"
          git push origin "$REVIEW_BRANCH"

          # Switch back to PR branch
          git checkout -

          # Get diff for display and format with visual indicators
          RAW_DIFF=$(git diff --unified=1 --no-color "origin/$REVIEW_BRANCH"^.."origin/$REVIEW_BRANCH")

          # Process diff to add emoji indicators and format for better visibility
          DIFF_OUTPUT=""
          while IFS= read -r line; do
            if [[ "$line" =~ ^diff\ --git ]]; then
              # File header
              DIFF_OUTPUT+="**${line#diff --git }**\n"
            elif [[ "$line" =~ ^--- || "$line" =~ ^\+\+\+ || "$line" =~ ^@@ ]]; then
              # Skip metadata lines
              continue
            elif [[ "$line" =~ ^-[^-] ]]; then
              # Deletion line (add red indicator)
              DIFF_OUTPUT+="üî¥ \`${line}\`\n"
            elif [[ "$line" =~ ^\+[^+] ]]; then
              # Addition line (add green indicator)
              DIFF_OUTPUT+="üü¢ \`${line}\`\n"
            elif [[ "$line" =~ ^[[:space:]] ]]; then
              # Context line
              DIFF_OUTPUT+="   \`${line}\`\n"
            fi
          done <<< "$RAW_DIFF"

          # Limit size
          DIFF_OUTPUT=$(echo -e "$DIFF_OUTPUT" | head -c 4000)

          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only "origin/$REVIEW_BRANCH"^.."origin/$REVIEW_BRANCH" | sed 's/^/- /')

          # Post review comment with diff
          COMMENT_BODY=$(jq -n \
            --arg files "$CHANGED_FILES" \
            --arg diff "$DIFF_OUTPUT" \
            '"## üìã Documentation Changes Ready for Review

            The following documentation changes have been generated based on your request.

            ### üìù Changed Files:
            \($files)

            ### üîç Proposed Changes:
            \($diff)

            ### ‚úÖ Approve or Reject

            Please review the changes above and:
            - Comment `@docbot approve` to apply these changes
            - Comment `@docbot reject` to discard these changes

            The changes are waiting on a temporary branch and will only be applied after your approval.

            ---
            ü§ñ *Automated by DocSync AI*"
            ' -r)

          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Changes Shown for Review" >> $GITHUB_STEP_SUMMARY
        fi

    - name: üìä Summary
      if: always()
      shell: bash
      env:
        VALID: ${{ steps.validate.outputs.valid }}
        IS_DOCSYNC: ${{ steps.verify-pr.outputs.is_docsync_pr }}
        HAS_CHANGES: ${{ steps.show-changes.outputs.has_changes }}
        APPROVED: ${{ steps.handle-approve.outputs.approved }}
        REJECTED: ${{ steps.handle-reject.outputs.rejected }}
        REVERTED: ${{ steps.handle-revert.outputs.reverted }}
      run: |
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## üìä Action Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Comment Valid**: ${VALID:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Is DocSync PR**: ${IS_DOCSYNC:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes Generated**: ${HAS_CHANGES:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes Approved**: ${APPROVED:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes Rejected**: ${REJECTED:-false}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes Reverted**: ${REVERTED:-false}" >> $GITHUB_STEP_SUMMARY
